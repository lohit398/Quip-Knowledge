"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copy = exports.pathExists = exports.readRecursive = exports.runCmdPromise = exports.runCmd = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const child_process_1 = require("child_process");
const fs_1 = tslib_1.__importDefault(require("fs"));
const minimatch_1 = tslib_1.__importDefault(require("minimatch"));
const ncp_1 = tslib_1.__importDefault(require("ncp"));
const path_1 = tslib_1.__importDefault(require("path"));
const print_1 = require("./print");
exports.runCmd = (cwd, command, ...args) => {
    return exports.runCmdPromise(cwd, command, ...args)
        .then((stdout) => {
        if (stdout) {
            print_1.println(stdout);
        }
    })
        .catch((error) => {
        print_1.println(chalk_1.default `{red Command failed: ${command} ${args.join(" ")}}`);
        print_1.println(chalk_1.default `{red CWD: ${cwd}}`);
        print_1.println(chalk_1.default `{red ${error.stack}}`);
        process.exit(1);
    });
};
exports.runCmdPromise = (cwd, command, ...args) => {
    return new Promise((resolve, reject) => {
        const cmd = child_process_1.spawn(command, [...args], {
            cwd,
            stdio: ["pipe", "pipe", "pipe"],
        });
        let stdout = "";
        cmd.stdout.on("data", (d) => {
            stdout += d;
        });
        cmd.on("error", (error) => {
            reject(error);
        });
        cmd.on("close", () => {
            resolve(stdout);
        });
    });
};
exports.readRecursive = async (dir, skip) => {
    return new Promise((resolve, reject) => {
        fs_1.default.readdir(dir, (err, children) => {
            if (err) {
                return reject(err);
            }
            Promise.all(children.map((child) => {
                if (child) {
                    if (minimatch_1.default(child, skip)) {
                        return Promise.resolve([]);
                    }
                }
                return new Promise((res, rej) => {
                    fs_1.default.stat(path_1.default.join(dir, child), (err, info) => {
                        if (err) {
                            return rej(err);
                        }
                        if (info.isDirectory()) {
                            res(exports.readRecursive(path_1.default.join(dir, child), skip).then((children) => children.map((file) => path_1.default.join(child, file))));
                        }
                        else {
                            res([child]);
                        }
                    });
                });
            })).then((childLists) => {
                resolve(childLists.reduce((all, child) => [...all, ...child], []));
            });
        });
    });
};
exports.pathExists = (filePath) => {
    return new Promise((resolve, reject) => {
        fs_1.default.stat(filePath, (err) => {
            if (err && err.code === "ENOENT") {
                return resolve(false);
            }
            else if (err) {
                return reject(err);
            }
            resolve(true);
        });
    });
};
exports.copy = (source, dest, options = {}) => {
    return new Promise((resolve, reject) => ncp_1.default(source, dest, options, (err) => {
        if (err) {
            return reject(err);
        }
        resolve();
    }));
};
