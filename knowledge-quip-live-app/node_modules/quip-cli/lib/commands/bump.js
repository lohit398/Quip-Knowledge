"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bump = void 0;
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const config_1 = require("../lib/config");
const manifest_1 = require("../lib/manifest");
const print_1 = require("../lib/print");
const util_1 = require("../lib/util");
exports.bump = async (dir, increment, options) => {
    const { message, silent, prereleaseName, noGit, versionNumber } = options || {};
    const packagePath = path_1.default.join(dir, "package.json");
    const manifestPath = await manifest_1.findManifest(dir);
    if (!manifestPath) {
        if (!silent) {
            print_1.println(chalk_1.default `{red Couldn't find manifest.json. Please execute at the root of your application.}`);
            process.exit(1);
        }
        else {
            return false;
        }
    }
    try {
        await fs_1.default.promises.stat(packagePath);
    }
    catch (e) {
        if (!silent) {
            print_1.println(chalk_1.default `{red Couldn't find package.json. Please execute at the root of your application.}`);
            process.exit(1);
        }
        else {
            return false;
        }
    }
    // read the package and get the next version
    const pkg = JSON.parse(await fs_1.default.promises.readFile(packagePath, "utf8"));
    let version = pkg.version;
    if (increment !== "none") {
        version = semver_1.default.inc(version, increment, prereleaseName);
        if (!version) {
            throw new Error(`Failed bumping version, semver doesn't understand ${version} as a valid version string.`);
        }
    }
    // update manifest.json to reflect the latest version
    const manifest = await manifest_1.getManifest(manifestPath);
    if (versionNumber) {
        manifest.version_number = versionNumber;
    }
    else {
        manifest.version_number += 1;
    }
    manifest.version_name = version;
    await manifest_1.writeManifest(manifestPath, manifest);
    if (!noGit) {
        // stage manifest.json since we want the increment to be part of our version tag
        try {
            await util_1.runCmdPromise(dir, "git", "add", manifestPath);
        }
        catch (e) {
            // silent failure ok here, since it just means we're not using git
        }
    }
    // run npm version to create the version tag and commit
    const extraArgs = [];
    if (message) {
        extraArgs.push("--message", message);
    }
    if (noGit) {
        extraArgs.push("--git-tag-version", "false");
    }
    // run with --force since we will have a dirty tree (cause we added manifest.json above)
    await util_1.runCmd(dir, config_1.NPM_BINARY_NAME, "version", "--force", version, ...extraArgs);
    if (!silent) {
        print_1.println(chalk_1.default `{magenta Successfully updated ${manifest.name} v${manifest.version_name} (${manifest.version_number})}`);
    }
    return true;
};
class Bump extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Bump);
        const increment = args.increment.toLowerCase();
        const manifestPath = await manifest_1.findManifest(process.cwd());
        const noGit = flags["no-git"];
        if (!manifestPath) {
            throw new Error("Couldn't find a quip app.");
        }
        if (!noGit) {
            let gitDirty = false;
            try {
                const r = await util_1.runCmdPromise(path_1.default.dirname(manifestPath), "git", "status", "--porcelain");
                gitDirty = r != "";
            }
            catch (e) {
                /* This just means that we're not in a git repo, safe to ignore. */
            }
            if (gitDirty) {
                throw new Error("Cannot bump version in a dirty repo. Commit your changes before running bump.");
            }
        }
        if (!["major", "minor", "patch", "prerelease", "none"].includes(increment)) {
            this._help();
            return;
        }
        exports.bump(process.cwd(), increment, {
            message: flags.message,
            prereleaseName: flags["prerelease-name"],
            versionNumber: flags["version-number"],
            noGit,
        });
    }
}
exports.default = Bump;
Bump.description = "Bump the application version (and create a version commit/tag)";
Bump.flags = {
    help: command_1.flags.help({ char: "h" }),
    message: command_1.flags.string({
        char: "m",
        description: "Specify a commit message to use as the version commit message",
    }),
    "version-number": command_1.flags.integer({
        char: "v",
        description: "Bump the version to a specific number rather than just incrementing to the next integer",
    }),
    "prerelease-name": command_1.flags.string({
        char: "p",
        description: "When specifying prerelease, use this as the prefix, e.g. -p alpha will produce v0.x.x-alpha.x",
    }),
    "no-git": command_1.flags.boolean({
        char: "n",
        description: "Don't perform git operations even when available (just makes changes inline)",
    }),
};
Bump.args = [
    {
        name: "increment",
        description: "which number to bump - can be one of 'prerelease', 'major', 'minor', 'patch', or 'none' - defaults to 'none'",
        default: "none",
    },
];
