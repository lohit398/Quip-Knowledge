"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_error_1 = __importDefault(require("./client-error"));
const record_index_1 = __importDefault(require("./record-index"));
const record_list_1 = __importDefault(require("./record-list"));
const RECORD_SENTINAL = {};
exports.isRecord = (obj) => obj.typeSentinal_ === RECORD_SENTINAL;
var RecordType;
(function (RecordType) {
    RecordType[RecordType["NONE"] = 0] = "NONE";
    RecordType[RecordType["RICH_TEXT"] = 1] = "RICH_TEXT";
    RecordType[RecordType["IMAGE"] = 2] = "IMAGE";
    RecordType[RecordType["LIST"] = 3] = "LIST";
    RecordType[RecordType["CANVAS"] = 4] = "CANVAS";
    RecordType[RecordType["COMMENT_ANCHOR"] = 5] = "COMMENT_ANCHOR";
})(RecordType = exports.RecordType || (exports.RecordType = {}));
class Record {
    constructor(client, pb, schema) {
        this.idValue = "test-id";
        this.uniqueIdValue = "test-unique-id";
        this.isDeletedValue = false;
        this.childrenIndexValue = new record_index_1.default();
        this.positionValue = "aaa";
        this.dataVersionValue = 1;
        this.parentIdValue = "parent-record-id";
        this.commentCountValue = 0;
        this.childrenValue = [];
        this.data_ = {};
        this.typeSentinal_ = RECORD_SENTINAL;
        const statics = this.constructor;
        const propTypes = statics.getProperties();
        let defaultProps = {};
        if ("getDefaultProperties" in this.constructor) {
            defaultProps = statics.getDefaultProperties();
        }
        for (const key in propTypes) {
            const value = defaultProps[key];
            if (value !== undefined) {
                this.set(key, value);
            }
        }
    }
    static getProperties() {
        return {};
    }
    static getDefaultProperties() {
        return {};
    }
    initialize() { }
    listen(listener) {
        // TODO
    }
    unlisten(listener) {
        // TODO
    }
    getChildrenIndex() {
        return this.childrenIndexValue;
    }
    id() {
        return this.idValue;
    }
    getId() {
        return this.id();
    }
    getUniqueId() {
        return this.uniqueIdValue;
    }
    isDeleted() {
        return this.isDeletedValue;
    }
    getData() {
        return this.data_;
    }
    getPosition() {
        return this.positionValue;
    }
    get(key) {
        // TODO: this is not exactly accurate for special types
        return this.data_[key];
    }
    has(key) {
        return key in this.data_;
    }
    set(key, value) {
        const statics = this.constructor;
        const propTypes = statics.getProperties();
        const Type = propTypes[key] || "UNKNOWN";
        if (typeof Type !== "string" &&
            "prototype" in Type &&
            Type.prototype instanceof Record) {
            const record = new Type();
            for (const key in value) {
                record.set(key, value[key]);
            }
            value = record;
        }
        else if (Type.TYPE_SENTINAL ===
            record_list_1.default.TYPE_SENTINAL) {
            const list = new record_list_1.default(null, Type.RecordConstructor);
            if (value) {
                for (const i in value) {
                    list.add(value[i]);
                }
            }
            value = list;
        }
        this.data_[key] = value;
    }
    clear(key, skipDelete) {
        const value = this.data_[key];
        delete this.data_[key];
        if (skipDelete && value && (value instanceof Record || value instanceof record_list_1.default)) {
            return value;
        }
    }
    clearData() {
        for (const key in this.data_) {
            this.clear(key);
        }
    }
    setDataVersion(version) {
        this.dataVersionValue = version;
    }
    getParent() {
        return this.parentValue;
    }
    getParentId() {
        return this.parentIdValue;
    }
    getParentRecord() {
        return this.parentRecordValue;
    }
    getContainingList() {
        return this.containingListValue;
    }
    setDeleted() { }
    delete() {
        this.isDeletedValue = true;
    }
    getPreviousSibling() {
        return this.previousSiblingValue;
    }
    getNextSibling() {
        return this.nextSiblingValue;
    }
    createSiblingBefore(recordParams) {
        // TODO:
        throw new Error("createSiblingBefore not yet supported in mock environment");
    }
    createSiblingAfter(recordParams) {
        // TODO:
        throw new Error("createSiblingBefore not yet supported in mock environment");
    }
    getChildren() {
        return this.childrenValue;
    }
    getCommentCount() {
        return this.commentCountValue;
    }
    getDataVersion() {
        return this.dataVersionValue;
    }
    getDom() {
        throw new client_error_1.default("Please override getDom() to return the DOM node for this " +
            "Record instance.");
    }
    isHighlightHidden() {
        return this.isHighlightHiddenValue;
    }
    listenToComments(listener) { }
    notifyListeners() {
        // TODO: this should probably trigger something to better simulate prod
    }
    setOrphanedState() { }
    supportsComments() {
        // override to change this
        return false;
    }
    unlistenToComments(listener) { }
}
exports.default = Record;
//# sourceMappingURL=record.js.map