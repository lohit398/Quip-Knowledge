"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.callAPI = exports.platformHost = exports.successOnly = exports.getStateString = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const https_1 = tslib_1.__importDefault(require("https"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const login_1 = require("../commands/login");
const config_1 = require("../lib/config");
const print_1 = require("../lib/print");
const isError = (response) => response && response.error;
exports.getStateString = () => `${new Date().getTime()}${process.env.USER}`;
exports.successOnly = async (promise, printJson) => {
    let response;
    try {
        response = await promise;
    }
    catch (e) {
        response = { error: "Request Failed:", response: e.message };
    }
    if (printJson) {
        print_1.println(JSON.stringify(response));
    }
    else if (isError(response)) {
        print_1.println(chalk_1.default `{red ${response.error}}`);
        if (response.response) {
            print_1.println(chalk_1.default `{red ${response.response || ""}}`);
        }
    }
    else {
        return response;
    }
    return false;
};
const UNAUTHORIZED = "unauthorized";
const cliAPI = async (configPath, site) => {
    let config = await config_1.readConfig(configPath);
    const doAPICall = async (path, method, data) => {
        if (!config.sites[site]) {
            return { error: `Not logged in to ${site}` };
        }
        const { accessToken } = config.sites[site];
        return exports.callAPI(site, path, method, data, accessToken).catch(async (e) => {
            if (e.message === UNAUTHORIZED) {
                return (login_1.login({ transparent: true, site })
                    .catch(() => {
                    // if our attempt to transparently login fails, just throw the original error.
                    throw e;
                })
                    .then(async () => {
                    // successfully logged in. Need to re-read the config.
                    config = await config_1.readConfig(configPath);
                })
                    // TODO: this hangs... not sure why
                    .then(() => doAPICall(path, method, data)));
            }
            else {
                throw e;
            }
        });
    };
    return doAPICall;
};
exports.platformHost = (site) => {
    const siteParts = site.split(".");
    if (site === "staging.quip.com") {
        return "platform-staging.quip.com";
    }
    if (siteParts.length > 2) {
        if (siteParts.slice(-2).join(".") === "onquip.com") {
            return `platform.${siteParts.slice(-3).join(".")}`;
        }
        return `platform.${siteParts.slice(-2).join(".")}`;
    }
    return `platform.${site}`;
};
exports.callAPI = async (site, path, method, data, accessToken) => {
    let headers = {
        "Content-Type": "application/json",
    };
    if (accessToken) {
        headers["Authorization"] = `Bearer ${accessToken}`;
    }
    let body;
    if (data === null || data === void 0 ? void 0 : data.getHeaders) {
        headers = Object.assign(Object.assign({}, headers), data.getHeaders());
        body = data;
    }
    else if (data) {
        body = JSON.stringify(data);
    }
    const request = await node_fetch_1.default(`https://${exports.platformHost(site)}/cli/${path}`, {
        agent: new https_1.default.Agent({
            rejectUnauthorized: config_1.SKIP_SSL_FOR_SITES.has(site) ? false : true,
        }),
        method: method || "get",
        body,
        headers,
    });
    if (request.status === 401 || request.status === 400) {
        throw new Error(UNAUTHORIZED);
    }
    const raw = await request.text();
    try {
        return JSON.parse(raw);
    }
    catch (e) {
        return { error: "Invalid response", response: raw };
    }
};
exports.default = cliAPI;
