"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeManifest = exports.getManifest = exports.findManifest = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const prettier_1 = tslib_1.__importDefault(require("prettier"));
const util_1 = require("./util");
exports.findManifest = async (dir) => {
    const allFiles = await util_1.readRecursive(dir, "node_modules");
    let minDistance = Infinity;
    let closestManifest;
    for (const file of allFiles) {
        const filename = path_1.default.basename(file);
        if (filename !== "manifest.json") {
            continue;
        }
        const fileDistance = file.split(path_1.default.sep).length;
        if (fileDistance <= minDistance) {
            minDistance = fileDistance;
            closestManifest = file;
        }
    }
    return closestManifest ? path_1.default.join(dir, closestManifest) : undefined;
};
const FIND_INDENT = /^{\n(\s+)[^\s]/;
const getManifestContent = async (manifestPath) => {
    if (!(await util_1.pathExists(manifestPath))) {
        throw new Error(`Manifest ${manifestPath} does not exist.`);
    }
    const content = (await fs_1.default.promises.readFile(manifestPath, "utf-8"));
    const formattingInfo = { indent: 2 };
    const indentMatch = content.match(FIND_INDENT);
    if (indentMatch) {
        formattingInfo.indent = indentMatch[1].length;
    }
    try {
        return [JSON.parse(content), formattingInfo];
    }
    catch (e) {
        throw new Error(`Failed parsing manifest: ${manifestPath}`);
    }
};
exports.getManifest = async (manifestPath) => {
    const [manifest] = await getManifestContent(manifestPath);
    return manifest;
};
exports.writeManifest = async (manifestPath, data) => {
    if (!(await util_1.pathExists(manifestPath))) {
        throw new Error(`Manifest ${manifestPath} does not exist.`);
    }
    const [manifest, { indent }] = await getManifestContent(manifestPath);
    // Note: should be obvious, but this won't do anything special for arrays.
    Object.assign(manifest, data);
    let prettierConfig = await prettier_1.default.resolveConfig(manifestPath);
    if (!prettierConfig) {
        prettierConfig = { tabWidth: indent };
    }
    await fs_1.default.promises.writeFile(manifestPath, prettier_1.default.format(JSON.stringify(manifest), Object.assign(Object.assign({}, prettierConfig), { parser: "json" })), "utf-8");
    return manifest;
};
