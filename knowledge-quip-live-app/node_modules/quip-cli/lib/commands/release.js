"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.release = exports.ReleaseDestination = void 0;
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_api_1 = tslib_1.__importStar(require("../lib/cli-api"));
const config_1 = require("../lib/config");
const manifest_1 = require("../lib/manifest");
const print_1 = require("../lib/print");
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
var ReleaseDestination;
(function (ReleaseDestination) {
    ReleaseDestination["BETA"] = "beta";
    ReleaseDestination["PROD"] = "prod";
})(ReleaseDestination = exports.ReleaseDestination || (exports.ReleaseDestination = {}));
exports.release = async (opts) => {
    const { manifest, build, destination, majorChanges } = opts;
    const fetch = await cli_api_1.default(opts.config, opts.site);
    return cli_api_1.successOnly(fetch(`app/${manifest.id}/release`, "post", {
        build,
        destination,
        major_changes: majorChanges,
    }), opts.json || false);
};
class Release extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Release);
        const manifestPath = await manifest_1.findManifest(process.cwd());
        if (!manifestPath) {
            throw new Error(`Could not find a manifest.json file.`);
        }
        const manifest = await manifest_1.getManifest(manifestPath);
        if (!flags.beta && !flags.prod) {
            this.error("Either --beta or --prod must be provided.");
        }
        let build = args.build;
        // if no build is provided, allow the user to select one
        if (!build) {
            const fetch = await cli_api_1.default(flags.config, flags.site);
            const dest = flags.beta ? "beta" : "prod";
            const versions = await cli_api_1.successOnly(fetch(`app/${manifest.id}/versions/releasable?destination=${dest}`), flags.json);
            if (!versions) {
                return;
            }
            if (versions.versions.length === 0) {
                print_1.println(chalk_1.default `{red No releasable versions. Publish a build first.}`);
                return;
            }
            print_1.println(chalk_1.default `{magenta ${versions.name}}`);
            const response = await inquirer_1.default.prompt([
                {
                    type: "list",
                    name: "version",
                    message: `Select a version to release as ${dest}:`,
                    choices: versions.versions.map((v) => ({
                        name: chalk_1.default `{green ${v.version_name} (${v.version_number})}`,
                        value: v.version_number,
                    })),
                },
            ]);
            if (!response || !response.version) {
                return;
            }
            build = response.version;
        }
        const response = await exports.release({
            manifest,
            destination: flags.beta
                ? ReleaseDestination.BETA
                : ReleaseDestination.PROD,
            build,
            site: flags.site,
            config: flags.config,
            json: flags.json,
            majorChanges: flags["major-changes"],
        });
        if (response) {
            print_1.println(chalk_1.default `{magenta Released version ${response.version_name} (${response.version_number}) as ${response.destination}.}`);
        }
    }
}
exports.default = Release;
Release.description = "Release an app to Beta or Production";
Release.flags = {
    help: command_1.flags.help({ char: "h" }),
    site: command_1.flags.string({
        char: "s",
        description: "use a specific quip site rather than the standard quip.com login",
        default: config_1.DEFAULT_SITE,
    }),
    beta: command_1.flags.boolean({
        char: "b",
        description: "release beta version",
        exclusive: ["prod"],
    }),
    prod: command_1.flags.boolean({
        char: "p",
        description: "release production version",
        exclusive: ["beta"],
    }),
    "major-changes": command_1.flags.enum({
        hidden: true,
        description: "First party only: required when using --prod. Pass either YES or NO to indicate if this build contains major security, availability, or confidentiality changes",
        options: ["YES", "NO"],
    }),
    json: command_1.flags.boolean({
        char: "j",
        description: "output responses in JSON",
    }),
    config: command_1.flags.string({
        hidden: true,
        description: "use a custom config file (default ~/.quiprc)",
        default: () => config_1.defaultConfigPath(),
    }),
};
Release.args = [
    {
        name: "build number",
        description: "the build number to release",
        parse: (arg) => parseInt(arg),
    },
];
